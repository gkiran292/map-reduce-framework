package org.iu.engrcloudcomputing.memcached.keyvaluestore.impl;

import io.grpc.stub.StreamObserver;
import org.iu.engrcloudcomputing.memcached.keyvaluestore.autogenerated.KeyValueStoreGrpc;
import org.iu.engrcloudcomputing.memcached.keyvaluestore.autogenerated.Keyvalue;
import org.iu.engrcloudcomputing.memcached.keyvaluestore.ds.UniqueLinkedBlockingQueue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.ConcurrentMap;

public class KeyValueStoreService extends KeyValueStoreGrpc.KeyValueStoreImplBase {

    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass().getSimpleName());
    private ConcurrentMap<String, String> concurrentMap;
    private UniqueLinkedBlockingQueue<String> blockingQueue;
    private String filePath;

    public KeyValueStoreService(ConcurrentMap<String, String> concurrentMap,
                                UniqueLinkedBlockingQueue<String> blockingQueue, String filePath) {

        this.concurrentMap = concurrentMap;
        this.blockingQueue = blockingQueue;
        this.filePath = filePath;
    }

    @Override
    public void set(Keyvalue.KeyValuePair request, StreamObserver<Keyvalue.Code> responseObserver) {
        String key = request.getKey();
        String value = request.getValue();

        concurrentMap.put(key, value);
        blockingQueue.offer(key + "~" + concurrentMap.get(key) + "\n");

        LOGGER.debug("Key: {}, Value: {}", key, value);
        try {
            persistInFile(filePath);
        } catch (IOException | InterruptedException | URISyntaxException e) {
            LOGGER.error(e.toString());
            responseObserver.onNext(Keyvalue.Code.newBuilder().setResponseCode(500).build());
            responseObserver.onCompleted();
        }

        responseObserver.onNext(Keyvalue.Code.newBuilder().setResponseCode(200).build());
        responseObserver.onCompleted();
    }

    private void persistInFile(String filePath) throws IOException, InterruptedException, URISyntaxException {
        File file = new File(new URI(filePath));
        if (!file.exists()) {
            if (!file.createNewFile()) {
                LOGGER.error("Couldn't create a new file: {}", filePath);
                throw new IOException("Couldn't create a new file" + filePath);
            }
        }

        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file.getAbsoluteFile(), true));
        bufferedWriter.write(blockingQueue.take());
        bufferedWriter.close();
    }

    @Override
    public void get(Keyvalue.Key request, StreamObserver<Keyvalue.KeyValuePair> responseObserver) {
        String key = request.getKey();
        String value = concurrentMap.get(key);
        int responseCode = 200;

        if(value == null) {
            responseCode = 500;
            LOGGER.debug("Value not found for key: {}", key);
            responseObserver.onNext(Keyvalue.KeyValuePair.newBuilder().setResponseCode(responseCode).build());
            responseObserver.onCompleted();
            return;
        }

        LOGGER.debug("Key: {}, Value: {}", key, value);
        responseObserver.onNext(Keyvalue.KeyValuePair.newBuilder()
                .setResponseCode(responseCode).setKey(key).setValue(value).build());
        responseObserver.onCompleted();
    }
}
