package org.iu.engrcloudcomputing.mapreduce.mapper.wordcountmapper;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.mutable.MutableInt;
import org.iu.engrcloudcomputing.mapreduce.mapper.wordcountmapper.autogenerated.KeyValueStoreGrpc;
import org.iu.engrcloudcomputing.mapreduce.mapper.wordcountmapper.autogenerated.Keyvalue;
import org.iu.engrcloudcomputing.mapreduce.mapper.wordcountmapper.autogenerated.MapperAckGrpc;
import org.iu.engrcloudcomputing.mapreduce.mapper.wordcountmapper.autogenerated.Master;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MapperClass {

    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass().getSimpleName());

    public static void main(String[] args) throws IOException, URISyntaxException {

        String kvStoreIpAddress = args[0];
        int kvStorePort = Integer.parseInt(args[1]);
        String masterIpAddress = args[2];
        int masterPort = Integer.parseInt(args[3]);
        String mapperId = args[4];
        String mapperKeysFilePath = args[5];

        LOGGER.info("kvStoreIpAddress: {}, kvStorePort: {}, masterIpAddress: {}, masterPort: {}, mapperId: {}, " +
                "mapperKeysFilePath: {}", kvStoreIpAddress, kvStorePort, masterIpAddress, masterPort, mapperId, mapperKeysFilePath);

        String keysFromFile = readFromFileForKeys(mapperKeysFilePath);

        KeyValueStoreGrpc.KeyValueStoreBlockingStub keyValueStoreBlockingStub = createKVStoreConnection(kvStoreIpAddress, kvStorePort);
        List<String> mapperKeys = processInputArguments(/*MapperId*/mapperId, /*mapper keys*/keysFromFile, keyValueStoreBlockingStub);

        MapperAckGrpc.MapperAckBlockingStub mapperAckBlockingStub = createMasterNodeConnection(masterIpAddress, masterPort);

        Master.Message response = mapperAckBlockingStub.mappedKeys(Master.Keys.newBuilder().addAllKey(mapperKeys).build());

        if (response.getResponseCode() != 200) {
            LOGGER.error("Sending data to master failed, responseCode: {}", response.getResponseCode());
        } else {
            LOGGER.info("Keys are successfully mapped");
        }
    }

    private static String readFromFileForKeys(String mapperKeysFilePath) throws IOException, URISyntaxException {

        File file = new File(new URI(mapperKeysFilePath));
        if (!file.exists()) {
            if (!file.createNewFile()) {
                LOGGER.error("Couldn't create a new file {}", mapperKeysFilePath);
                throw new IOException("Couldn't create a new file " + mapperKeysFilePath);
            }
        }

        BufferedReader br = new BufferedReader(new FileReader(file.getAbsoluteFile()));

        String line = br.readLine();
        br.close();

        return line;
    }

    private static List<String> processInputArguments(String mapperId, String inputArgs,
                                                      KeyValueStoreGrpc.KeyValueStoreBlockingStub blockingStub) {

        Map<String, MutableInt> map = new HashMap<>();
        List<String> finalKeys = new ArrayList<>();
        String[] mapperInput = inputArgs.split(",");


        for (String key : mapperInput) {
            Keyvalue.KeyValuePair keyValuePair = blockingStub.get(Keyvalue.Key.newBuilder().setKey(key).build());

            if (StringUtils.isNotEmpty(key)) {
                mapperFunctionImpl(mapperId, keyValuePair, map);
            }
        }

        for (Map.Entry<String, MutableInt> mapEntry : map.entrySet()) {
            String key = mapEntry.getKey();
            MutableInt val = mapEntry.getValue();

            Keyvalue.Code responseCode = blockingStub.set(Keyvalue.KeyValuePair.newBuilder().setKey(key)
                    .setValue(val.getValue().toString()).build());
            if (responseCode.getResponseCode() != 200) {
                LOGGER.error("Not ale to store key: {}, value: {} in KV Store", key, val);
            } else {
                finalKeys.add(key);
            }
        }

        return finalKeys;
    }

    private static void mapperFunctionImpl(String mapperId, Keyvalue.KeyValuePair keyValuePair,
                                           Map<String, MutableInt> map) {

        String value = keyValuePair.getValue();

        String[] words = value.split("\\s");

        for (String word : words) {
            word = word.replaceAll("[\\p{Punct}&&[^0-9]&&[^-]]", "");

            String mapperKey = mapperId + "_" + word;
            LOGGER.debug("Mapper key: {}", mapperKey);
            MutableInt mi = map.get(mapperKey);

            if (mi == null) {
                map.put(mapperKey, new MutableInt(1));
            } else {
                mi.increment();
            }
        }
    }

    private static KeyValueStoreGrpc.KeyValueStoreBlockingStub createKVStoreConnection(String kvStoreIpAddress, int kvStorePort) {
        ManagedChannel channel = ManagedChannelBuilder.forAddress(kvStoreIpAddress, kvStorePort).usePlaintext().build();
        return KeyValueStoreGrpc.newBlockingStub(channel);
    }

    private static MapperAckGrpc.MapperAckBlockingStub createMasterNodeConnection(String masterIpAddress, int masterPort) {
        ManagedChannel channel = ManagedChannelBuilder.forAddress(masterIpAddress, masterPort).usePlaintext().build();
        return MapperAckGrpc.newBlockingStub(channel);
    }
}
