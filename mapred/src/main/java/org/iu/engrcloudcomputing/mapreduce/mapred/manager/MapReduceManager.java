package org.iu.engrcloudcomputing.mapreduce.mapred.manager;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import org.apache.commons.lang3.StringUtils;
import org.iu.engrcloudcomputing.mapreduce.mapred.autogenerated.KeyValueStoreGrpc;
import org.iu.engrcloudcomputing.mapreduce.mapred.autogenerated.Keyvalue;
import org.iu.engrcloudcomputing.mapreduce.mapred.helper.JavaProcessBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.zeroturnaround.exec.ProcessResult;

import java.io.*;
import java.lang.invoke.MethodHandles;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.*;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class MapReduceManager {

    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass().getSimpleName());

    private String kvStoreIpAddress;
    private int kvStorePort;
    private String masterIpAddress;
    private int masterPort;
    private int mappers;
    private int reducers;
    private String mapperJarName;
    private String reducerJarName;
    private String initialKey;
    private String workingFolder;
    private ConcurrentMap<String, String> mapperConcurrentMap;
    private ConcurrentMap<String, String> reducerConcurrentMap;

    public MapReduceManager(String kvStoreIpAddress, int kvStorePort, String masterIpAddress, int masterPort, int mappers,
                            int reducers, String mapperJarName, String reducerJarName, String initialKey, String workingFolder,
                            ConcurrentMap<String, String> mapperConcurrentMap, ConcurrentMap<String, String> reducerConcurrentMap) {
        this.kvStoreIpAddress = kvStoreIpAddress;
        this.kvStorePort = kvStorePort;
        this.masterIpAddress = masterIpAddress;
        this.masterPort = masterPort;
        this.mappers = mappers;
        this.reducers = reducers;
        this.mapperJarName = mapperJarName;
        this.reducerJarName = reducerJarName;
        this.initialKey = initialKey;
        this.workingFolder = workingFolder;
        this.mapperConcurrentMap = mapperConcurrentMap;
        this.reducerConcurrentMap = reducerConcurrentMap;
    }

    public List<String> mapReduce() throws IOException, ExecutionException, InterruptedException, URISyntaxException {

        KeyValueStoreGrpc.KeyValueStoreBlockingStub blockingStub = createConnection();

        Keyvalue.KeyValuePair keyValuePair = blockingStub.get(Keyvalue.Key.newBuilder().setKey(initialKey).build());

        String inputValue = keyValuePair.getValue();
        String[] split = inputValue.split(",");

        List<String> filePaths = new ArrayList<>(Arrays.asList(split));
        List<String> totalKeys = splitAndStoreInput(blockingStub, filePaths);

        //Logic for splitting input
        List<String> inputKeys = splitInputKeys(totalKeys, mappers);
        //spawn mappers
        List<Future<ProcessResult>> mapperFutureList = spawnTaskProcesses("M", inputKeys, mapperJarName);

        //wait for mappers to finish
        for (Future<ProcessResult> future : mapperFutureList) {
            ProcessResult processResult = future.get();
            if (processResult.getExitValue() != 0) {
                LOGGER.error("Exception occurred mapper task not completed");
            }
        }

        //process the keys for reducers
        List<String> reducerKeyList = processKeysForReducers(mapperConcurrentMap, reducers);
        //spawn reducers
        List<Future<ProcessResult>> reducerFutureList = spawnTaskProcesses("R", reducerKeyList, reducerJarName);

        //wait for reducers to finish
        for (Future<ProcessResult> future : reducerFutureList) {
            future.get();
        }

        //mappers and reducers have finished their tasks
        //TODO:send output to key value store and send the acknowledgement back to the main which presents the output to the user

        List<String> finalKeys = new ArrayList<>();
        for (Map.Entry<String, String> mapEntry : reducerConcurrentMap.entrySet()) {
            String keyString = mapEntry.getKey();

            Keyvalue.KeyValuePair finalKVPair = blockingStub.get(Keyvalue.Key.newBuilder().setKey(keyString).build());
            String[] s = finalKVPair.getKey().split("_");
            LOGGER.debug("Setting the final value for key: {}, reducerId: {}", s[1], s[0]);
            Keyvalue.Code responseCode = blockingStub.set(Keyvalue.KeyValuePair.newBuilder().setKey(s[1])
                    .setValue(finalKVPair.getValue()).build());

            if (responseCode.getResponseCode() != 200) {
                LOGGER.error("Couldn't store the value for the key, key: {}, value: {}", s[1], finalKVPair.getValue());
            } else {
                finalKeys.add(s[1]);
                LOGGER.debug("Successfully stored for the key, key: {}, value: {}", s[1], finalKVPair.getValue());
            }
        }

//        for (String str : finalKeys) {
//            Keyvalue.KeyValuePair finalKVPair = blockingStub.get(Keyvalue.Key.newBuilder().setKey(str).build());
//
//            LOGGER.info(finalKVPair.getKey() + " ====> " + finalKVPair.getValue());
//        }

        return finalKeys;
    }

    private List<String> processKeysForReducers(ConcurrentMap<String, String> mapperConcurrentMap,
                                                int reducerCount) {

        Set<String> mapperSet = new HashSet<>();
        Set<String> keySet = new HashSet<>();

        List<String> reducerKeyList = new ArrayList<>();

        for (Map.Entry<String, String> mapEntry : mapperConcurrentMap.entrySet()) {

            String key = mapEntry.getKey();

            String[] mapper_key = key.split("_");

            keySet.add(mapper_key[1]);
            mapperSet.add(mapper_key[0]);
        }

        List<String> reducerKeys = splitInputKeys(new ArrayList<>(keySet), reducerCount);

        for (String splitKeys : reducerKeys) {
            String[] keys = splitKeys.split(",");

            StringBuilder sb = new StringBuilder();
            for (String key : keys) {
                for (String mapperId : mapperSet) {
                    sb.append(StringUtils.join(mapperId + "_" + key, ","));
                }
            }

            String finalKey = sb.toString();
            reducerKeyList.add(StringUtils.stripEnd(finalKey, ","));
        }

        return reducerKeyList;
    }

    private List<String> splitInputKeys(List<String> totalKeys, int nodeCount) {

        final int chunkSize;

        if (totalKeys.size() % nodeCount == 0) {
            chunkSize = totalKeys.size() / nodeCount;
        } else {
            chunkSize = (totalKeys.size() + nodeCount) / nodeCount;
        }

        final AtomicInteger counter = new AtomicInteger();
        return totalKeys.stream()
                .collect(Collectors.groupingBy(it -> counter.getAndIncrement() / chunkSize))
                .values().stream()
                .map(list -> StringUtils.join(list, ","))
                .collect(Collectors.toList());
    }

    private List<Future<ProcessResult>> spawnTaskProcesses(String prefix, List<String> inputKeys, String mainClass) throws IOException, URISyntaxException {

        List<Future<ProcessResult>> futureList = new ArrayList<>();
        int i = 0;
        for (String input : inputKeys) {
            final String uuid = prefix + UUID.randomUUID().toString().replace("-", "") + (++i);

            String filePath = uuid + ".txt";
            String uri = persistInFile(input, filePath);
            JavaProcessBuilder javaProcessBuilder = new JavaProcessBuilder();
            javaProcessBuilder.addArgument(kvStoreIpAddress);
            javaProcessBuilder.addArgument(String.valueOf(kvStorePort));
            javaProcessBuilder.addArgument(masterIpAddress);
            javaProcessBuilder.addArgument(String.valueOf(masterPort));
            javaProcessBuilder.addArgument(uuid);
            javaProcessBuilder.addArgument(uri);
            javaProcessBuilder.setJarPath(mainClass);
            futureList.add(javaProcessBuilder.asyncStartProcess());
            LOGGER.info("TaskId: {}", uuid);
        }

        return futureList;
    }

    private KeyValueStoreGrpc.KeyValueStoreBlockingStub createConnection() {
        ManagedChannel channel = ManagedChannelBuilder.forAddress(kvStoreIpAddress, kvStorePort).usePlaintext().build();
        return KeyValueStoreGrpc.newBlockingStub(channel);
    }

    private void storeKeyValue(KeyValueStoreGrpc.KeyValueStoreBlockingStub blockingStub, String key, String value) {

        Keyvalue.Code code = blockingStub.set(Keyvalue.KeyValuePair.newBuilder().setKey(key).setValue(value).build());

        if (code == null || code.getResponseCode() != 200) {
            LOGGER.error("Couldn't store the key: {}, value: {}", key, value);
        }

        LOGGER.info("Key Value Successfully stored, key: {}, value: {}", key, value);
    }

    private List<String> splitAndStoreInput(KeyValueStoreGrpc.KeyValueStoreBlockingStub blockingStub,
                                            List<String> filePaths) throws IOException {

        List<String> totalKeyList = new ArrayList<>();

        for (String filePath : filePaths) {
            File file = new File(filePath);
            if (!file.exists()) {
                if (!file.createNewFile()) {
                    LOGGER.error("Couldn't create a new file {}", filePath);
                    throw new IOException("Couldn't create a new file " + filePath);
                }
            }

            BufferedReader br = new BufferedReader(new FileReader(file.getAbsoluteFile()));

            String line;
            int count = 0;
            String key;
            while ((line = br.readLine()) != null) {
                count++;
                key = (filePath + "_" + count);
                storeKeyValue(blockingStub, (filePath + "_" + count), line);
                totalKeyList.add(key);
            }

            br.close();
        }

        return totalKeyList;
    }

    private String persistInFile(String input, String filePath) throws IOException, URISyntaxException {

        String uri = "file://" + workingFolder + "/" + filePath;
        File file = new File(new URI(uri));
        if (!file.exists()) {
            if (!file.createNewFile()) {
                LOGGER.error("Couldn't create a new file {}", filePath);
                throw new IOException("Couldn't create a new file " + filePath);
            }
        }

        BufferedWriter bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile(), false));
        try {
            bw.write(input + "\n");
        } catch (IOException e) {
            LOGGER.error("Couldn't write to file {}", filePath);
        }

        bw.close();

        return uri;
    }
}
