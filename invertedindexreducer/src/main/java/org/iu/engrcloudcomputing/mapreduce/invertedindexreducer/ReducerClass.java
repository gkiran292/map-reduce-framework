package org.iu.engrcloudcomputing.mapreduce.invertedindexreducer;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import org.apache.commons.lang3.mutable.MutableInt;
import org.iu.engrcloudcomputing.mapreduce.invertedindexreducer.autogenerated.KeyValueStoreGrpc;
import org.iu.engrcloudcomputing.mapreduce.invertedindexreducer.autogenerated.Keyvalue;
import org.iu.engrcloudcomputing.mapreduce.invertedindexreducer.autogenerated.Master;
import org.iu.engrcloudcomputing.mapreduce.invertedindexreducer.autogenerated.ReducerAckGrpc;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ReducerClass {

    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass().getSimpleName());

    public static void main(String[] args) throws IOException, URISyntaxException {

        String kvStoreIpAddress = args[0];
        int kvStorePort = Integer.parseInt(args[1]);
        String masterIpAddress = args[2];
        int masterPort = Integer.parseInt(args[3]);
        String reducerId = args[4];
        String reducerKeysFilePath = args[5];

        LOGGER.info("kvStoreIpAddress: {}, kvStorePort: {}, masterIpAddress: {}, masterPort: {}, reducerId: {}, " +
                "reducerKeysFilePath: {}", kvStoreIpAddress, kvStorePort, masterIpAddress, masterPort, reducerId, reducerKeysFilePath);

        String keysFromFile = readFromFileForKeys(reducerKeysFilePath);

        KeyValueStoreGrpc.KeyValueStoreBlockingStub keyValueStoreBlockingStub = createKVStoreConnection(kvStoreIpAddress, kvStorePort);
        List<String> mapperKeys = processInputArguments(/*ReducerId*/reducerId, /*reducer keys*/keysFromFile, keyValueStoreBlockingStub);

        ReducerAckGrpc.ReducerAckBlockingStub reducerAckBlockingStub = createMasterNodeConnection(masterIpAddress, masterPort);

        Master.Message response = reducerAckBlockingStub.reduceKeys(Master.Keys.newBuilder().addAllKey(mapperKeys).build());

        if (response.getResponseCode() != 200) {
            LOGGER.error("Sending data to master failed, responseCode: {}", response.getResponseCode());
        } else {
            LOGGER.info("Keys are successfully reduced");
        }
    }

    private static String readFromFileForKeys(String mapperKeysFilePath) throws IOException, URISyntaxException {

        File file = new File(new URI(mapperKeysFilePath));
        if (!file.exists()) {
            if (!file.createNewFile()) {
                LOGGER.error("Couldn't create a new file {}", mapperKeysFilePath);
                throw new IOException("Couldn't create a new file " + mapperKeysFilePath);
            }
        }

        BufferedReader br = new BufferedReader(new FileReader(file.getAbsoluteFile()));

        String line = br.readLine();
        br.close();

        return line;
    }

    private static List<String> processInputArguments(String reducerId, String inputArgs,
                                                      KeyValueStoreGrpc.KeyValueStoreBlockingStub blockingStub) {

        Map<String, Map<String, MutableInt>> map = new HashMap<>();
        List<String> finalKeys = new ArrayList<>();
        String[] mapperInput = inputArgs.split(",");


        for (String key : mapperInput) {
            Keyvalue.KeyValuePair keyValuePair = blockingStub.get(Keyvalue.Key.newBuilder().setKey(key).build());

            if (keyValuePair.getResponseCode() == 200) {
                reducerFunctionImpl(reducerId, keyValuePair, map);
            }
        }

        for (Map.Entry<String, Map<String, MutableInt>> mapEntry : map.entrySet()) {
            String key = mapEntry.getKey();
            Map<String, MutableInt> val = mapEntry.getValue();

            String finalVal = val.entrySet().stream()
                    .map(keyValPair -> keyValPair.getKey() + ":" + keyValPair.getValue().getValue())
                    .collect(Collectors.joining(","));

            Keyvalue.Code responseCode = blockingStub.set(Keyvalue.KeyValuePair.newBuilder().setKey(key)
                    .setValue(finalVal).build());
            if (responseCode.getResponseCode() != 200) {
                LOGGER.error("Not ale to store key: {}, value: {} in KV Store", key, finalVal);
            } else {
                finalKeys.add(key);
            }
        }

        return finalKeys;
    }

    private static void reducerFunctionImpl(String reducerId, Keyvalue.KeyValuePair keyValuePair,
                                            Map<String, Map<String, MutableInt>> map) {

        String key = keyValuePair.getKey().split("_")[1];
        String value = keyValuePair.getValue();

        String[] words = value.split(",");

        for (String word : words) {
            String[] split = word.split(":");

            LOGGER.debug("Reducing values for key: {}, value: {}, count: {}", key, split[0], split[1]);
            String reducerKey = reducerId + "_" + key;
            if (map.containsKey(reducerKey)) {
                MutableInt mi = map.get(reducerKey).get(split[0]);

                if (mi == null) {
                    map.get(reducerKey).put(split[0], new MutableInt(Integer.parseInt(split[1])));
                } else {
                    mi.add(Integer.parseInt(split[1]));
                }
            } else {
                Map<String, MutableInt> newMap = new HashMap<>();
                newMap.put(split[0], new MutableInt(Integer.parseInt(split[1])));
                map.put(reducerKey, newMap);
            }
            LOGGER.debug("Reducer key: {}", reducerKey);
        }
    }

    private static KeyValueStoreGrpc.KeyValueStoreBlockingStub createKVStoreConnection(String kvStoreIpAddress, int kvStorePort) {
        //TODO: change the argument and get the value from property file
        ManagedChannel channel = ManagedChannelBuilder.forAddress(kvStoreIpAddress, kvStorePort).usePlaintext().build();
        return KeyValueStoreGrpc.newBlockingStub(channel);
    }

    private static ReducerAckGrpc.ReducerAckBlockingStub createMasterNodeConnection(String masterIpAddress, int masterPort) {
        //TODO: change the argument and get the value from property file
        ManagedChannel channel = ManagedChannelBuilder.forAddress(masterIpAddress, masterPort).usePlaintext().build();
        return ReducerAckGrpc.newBlockingStub(channel);
    }
}