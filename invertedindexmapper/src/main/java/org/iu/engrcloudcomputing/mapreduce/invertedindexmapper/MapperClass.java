package org.iu.engrcloudcomputing.mapreduce.invertedindexmapper;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.mutable.MutableInt;
import org.iu.engrcloudcomputing.mapreduce.invertedindexmapper.autogenerated.KeyValueStoreGrpc;
import org.iu.engrcloudcomputing.mapreduce.invertedindexmapper.autogenerated.Keyvalue;
import org.iu.engrcloudcomputing.mapreduce.invertedindexmapper.autogenerated.MapperAckGrpc;
import org.iu.engrcloudcomputing.mapreduce.invertedindexmapper.autogenerated.Master;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class MapperClass {

    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass().getSimpleName());

    public static void main(String[] args) throws IOException, URISyntaxException {

        String kvStoreIpAddress = args[0];
        int kvStorePort = Integer.parseInt(args[1]);
        String masterIpAddress = args[2];
        int masterPort = Integer.parseInt(args[3]);
        String mapperId = args[4];
        String mapperKeysFilePath = args[5];

        LOGGER.info("kvStoreIpAddress: {}, kvStorePort: {}, masterIpAddress: {}, masterPort: {}, mapperId: {}, " +
                "mapperKeysFilePath: {}", kvStoreIpAddress, kvStorePort, masterIpAddress, masterPort, mapperId, mapperKeysFilePath);

        String keysFromFile = readFromFileForKeys(mapperKeysFilePath);

        KeyValueStoreGrpc.KeyValueStoreBlockingStub keyValueStoreBlockingStub = createKVStoreConnection(kvStoreIpAddress, kvStorePort);
        List<String> mapperKeys = processInputArguments(/*MapperId*/mapperId, /*mapper keys*/keysFromFile, keyValueStoreBlockingStub);

        MapperAckGrpc.MapperAckBlockingStub mapperAckBlockingStub = createMasterNodeConnection(masterIpAddress, masterPort);

        Master.Message response = mapperAckBlockingStub.mappedKeys(Master.Keys.newBuilder().addAllKey(mapperKeys).build());

        if (response.getResponseCode() != 200) {
            LOGGER.error("Sending data to master failed, responseCode: {}", response.getResponseCode());
        } else {
            LOGGER.info("Keys are successfully mapped");
        }
    }

    private static String readFromFileForKeys(String mapperKeysFilePath) throws IOException, URISyntaxException {

        File file = new File(new URI(mapperKeysFilePath));
        if (!file.exists()) {
            if (!file.createNewFile()) {
                LOGGER.error("Couldn't create a new file {}", mapperKeysFilePath);
                throw new IOException("Couldn't create a new file " + mapperKeysFilePath);
            }
        }

        BufferedReader br = new BufferedReader(new FileReader(file.getAbsoluteFile()));

        String line = br.readLine();
        br.close();

        return line;
    }

    private static List<String> processInputArguments(String mapperId, String inputArgs,
                                                      KeyValueStoreGrpc.KeyValueStoreBlockingStub blockingStub) {

        Map<String, Map<String, MutableInt>> map = new HashMap<>();
        List<String> finalKeys = new ArrayList<>();
        String[] mapperInput = inputArgs.split(",");


        for (String key : mapperInput) {
            Keyvalue.KeyValuePair keyValuePair = blockingStub.get(Keyvalue.Key.newBuilder().setKey(key).build());

            if (StringUtils.isNotEmpty(key)) {
                mapperFunctionImpl(mapperId, keyValuePair, map);
            }
        }

        for (Map.Entry<String, Map<String, MutableInt>> mapEntry : map.entrySet()) {
            String key = mapEntry.getKey();
            Map<String, MutableInt> val = mapEntry.getValue();

            String finalVal = val.entrySet().stream()
                    .map(keyValPair -> keyValPair.getKey() + ":" + keyValPair.getValue().getValue())
                    .collect(Collectors.joining(","));

            Keyvalue.Code responseCode = blockingStub.set(Keyvalue.KeyValuePair.newBuilder().setKey(key)
                    .setValue(finalVal).build());
            if (responseCode.getResponseCode() != 200) {
                LOGGER.error("Not ale to store key: {}, value: {} in KV Store", key, finalVal);
            } else {
                finalKeys.add(key);
            }
        }

        return finalKeys;
    }

    private static void mapperFunctionImpl(String mapperId, Keyvalue.KeyValuePair keyValuePair,
                                           Map<String, Map<String, MutableInt>> map) {

        String key = keyValuePair.getKey().split("_")[0];
        String value = keyValuePair.getValue();

        String[] words = value.split("\\s");

        for (String word : words) {
            word = word.replaceAll("[\\p{Punct}&&[^0-9]&&[^-]]", "");

            String mapperKey = mapperId + "_" + word;
            LOGGER.debug("Mapper key: {}", mapperKey);
            if (map.containsKey(mapperKey)) {
                MutableInt mi = map.get(mapperKey).get(key);

                if (mi == null) {
                    map.get(mapperKey).put(key, new MutableInt(1));
                } else {
                    mi.increment();
                }
            } else {
                Map<String, MutableInt> newMap = new HashMap<>();
                newMap.put(key, new MutableInt(1));
                map.put(mapperKey, newMap);
            }
        }
    }

    private static KeyValueStoreGrpc.KeyValueStoreBlockingStub createKVStoreConnection(String kvStoreIpAddress, int kvStorePort) {
        ManagedChannel channel = ManagedChannelBuilder.forAddress(kvStoreIpAddress, kvStorePort).usePlaintext().build();
        return KeyValueStoreGrpc.newBlockingStub(channel);
    }

    private static MapperAckGrpc.MapperAckBlockingStub createMasterNodeConnection(String masterIpAddress, int masterPort) {
        ManagedChannel channel = ManagedChannelBuilder.forAddress(masterIpAddress, masterPort).usePlaintext().build();
        return MapperAckGrpc.newBlockingStub(channel);
    }
}
